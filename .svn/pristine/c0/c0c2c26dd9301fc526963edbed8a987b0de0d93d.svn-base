/*
 * This source file was generated by FireStorm/DAO.
 * 
 * If you purchase a full license for FireStorm/DAO you can customize this header file.
 * 
 * For more information please visit http://www.codefutures.com/products/firestorm
 */

package com.sorin.idea.jdbc;

import com.sorin.idea.dao.*;
import com.sorin.idea.factory.*;
import com.sorin.idea.util.UtilCodifi;
import com.sorin.idea.util.UtilFechas;

import java.util.Date;
import com.sorin.idea.dto.*;
import com.sorin.idea.exceptions.*;
import java.sql.Connection;
import java.util.Collection;
import java.sql.PreparedStatement;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Time;
import java.util.List;
import java.util.Iterator;
import java.util.ArrayList;

public class HolterDaoImpl extends AbstractDAO implements HolterDao
{
	private AuditoriaDao auditoriaDao = new AuditoriaDao();
    private AuditoriaDto auditoriaDto = null;
	/** 
	 * The factory class for this DAO has two versions of the create() method - one that
takes no arguments and one that takes a Connection argument. If the Connection version
is chosen then the connection will be stored in this attribute and will be used by all
calls to this DAO, otherwise a new Connection will be allocated for each operation.
	 */
	protected java.sql.Connection userConn;

	/** 
	 * All finder methods in this class use this SELECT constant to build their queries
	 */
	protected final String SQL_SELECT = "SELECT IDHOLTER, FECHACOLOCACION, FECHALECTURA, FECHARETIRADA, FECHANALISIS, ESTADO, COMENTARIOS_COL, COMENTARIOS_ANA, RECOMENDACIONES, DIAGNOSTICOINI, DIAGNOSTICOFIN, REFERIDOR, COLOCACION_ENF, COLOCACION_MED, ANALISIS_MED, RETIRADA_ENF, RETIRADA_MED, NPROC, DIAGINIOTRO, DIAGFINOTRO FROM " + getTableName() + "";

	/** 
	 * Finder methods will pass this value to the JDBC setMaxRows method
	 */
	protected int maxRows;

	/** 
	 * SQL INSERT statement for this table
	 */
	protected final String SQL_INSERT = "INSERT INTO " + getTableName() + " ( IDHOLTER, FECHACOLOCACION, FECHALECTURA, FECHARETIRADA, FECHANALISIS, ESTADO, COMENTARIOS_COL, COMENTARIOS_ANA, RECOMENDACIONES, DIAGNOSTICOINI, DIAGNOSTICOFIN, REFERIDOR, COLOCACION_ENF, COLOCACION_MED, ANALISIS_MED, RETIRADA_ENF, RETIRADA_MED, NPROC, DIAGINIOTRO, DIAGFINOTRO ) VALUES ( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? )";

	/** 
	 * SQL UPDATE statement for this table
	 */
	protected final String SQL_UPDATE = "UPDATE " + getTableName() + " SET IDHOLTER = ?, FECHACOLOCACION = ?, FECHALECTURA = ?, FECHARETIRADA = ?, FECHANALISIS = ?, ESTADO = ?, COMENTARIOS_COL = ?, COMENTARIOS_ANA = ?, RECOMENDACIONES = ?, DIAGNOSTICOINI = ?, DIAGNOSTICOFIN = ?, REFERIDOR = ?, COLOCACION_ENF = ?, COLOCACION_MED = ?, ANALISIS_MED = ?, RETIRADA_ENF = ?, RETIRADA_MED = ?, NPROC = ?, DIAGINIOTRO = ?, DIAGFINOTRO = ? WHERE IDHOLTER = ?";

	/** 
	 * SQL DELETE statement for this table
	 */
	protected final String SQL_DELETE = "DELETE FROM " + getTableName() + " WHERE IDHOLTER = ?";

	/** 
	 * Index of column IDHOLTER
	 */
	protected static final int COLUMN_IDHOLTER = 1;

	/** 
	 * Index of column FECHACOLOCACION
	 */
	protected static final int COLUMN_FECHACOLOCACION = 2;

	/** 
	 * Index of column FECHALECTURA
	 */
	protected static final int COLUMN_FECHALECTURA = 3;

	/** 
	 * Index of column FECHARETIRADA
	 */
	protected static final int COLUMN_FECHARETIRADA = 4;

	/** 
	 * Index of column FECHANALISIS
	 */
	protected static final int COLUMN_FECHANALISIS = 5;

	/** 
	 * Index of column ESTADO
	 */
	protected static final int COLUMN_ESTADO = 6;

	/** 
	 * Index of column COMENTARIOS_COL
	 */
	protected static final int COLUMN_COMENTARIOS_COL = 7;

	/** 
	 * Index of column COMENTARIOS_ANA
	 */
	protected static final int COLUMN_COMENTARIOS_ANA = 8;

	/** 
	 * Index of column RECOMENDACIONES
	 */
	protected static final int COLUMN_RECOMENDACIONES = 9;

	/** 
	 * Index of column DIAGNOSTICOINI
	 */
	protected static final int COLUMN_DIAGNOSTICOINI = 10;

	/** 
	 * Index of column DIAGNOSTICOFIN
	 */
	protected static final int COLUMN_DIAGNOSTICOFIN = 11;

	/** 
	 * Index of column REFERIDOR
	 */
	protected static final int COLUMN_REFERIDOR = 12;

	/** 
	 * Index of column COLOCACION_ENF
	 */
	protected static final int COLUMN_COLOCACION_ENF = 13;

	/** 
	 * Index of column COLOCACION_MED
	 */
	protected static final int COLUMN_COLOCACION_MED = 14;

	/** 
	 * Index of column ANALISIS_MED
	 */
	protected static final int COLUMN_ANALISIS_MED = 15;

	/** 
	 * Index of column RETIRADA_ENF
	 */
	protected static final int COLUMN_RETIRADA_ENF = 16;

	/** 
	 * Index of column RETIRADA_MED
	 */
	protected static final int COLUMN_RETIRADA_MED = 17;

	/** 
	 * Index of column NPROC
	 */
	protected static final int COLUMN_NPROC = 18;

	/** 
	 * Index of column DIAGINIOTRO
	 */
	protected static final int COLUMN_DIAGINIOTRO = 19;

	/** 
	 * Index of column DIAGFINOTRO
	 */
	protected static final int COLUMN_DIAGFINOTRO = 20;

	/** 
	 * Number of columns
	 */
	protected static final int NUMBER_OF_COLUMNS = 20;

	/** 
	 * Index of primary-key column IDHOLTER
	 */
	protected static final int PK_COLUMN_IDHOLTER = 1;

	/** 
	 * Inserts a new row in the holter table.
	 */
	public HolterPk insert(Holter dto) throws HolterDaoException
	{
		long t1 = System.currentTimeMillis();
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		
		try {
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
		
			stmt = conn.prepareStatement( SQL_INSERT, Statement.RETURN_GENERATED_KEYS );
			int index = 1;
			if (dto.getIdholter() != null) {
				stmt.setInt( index++, dto.getIdholter().intValue() );
			} else {
				stmt.setNull(index++, java.sql.Types.INTEGER);
			}
		
			stmt.setDate(index++, dto.getFechacolocacion()==null ? null : new java.sql.Date( dto.getFechacolocacion().getTime() ) );
			stmt.setDate(index++, dto.getFechalectura()==null ? null : new java.sql.Date( dto.getFechalectura().getTime() ) );
			stmt.setDate(index++, dto.getFecharetirada()==null ? null : new java.sql.Date( dto.getFecharetirada().getTime() ) );
			stmt.setDate(index++, dto.getFechanalisis()==null ? null : new java.sql.Date( dto.getFechanalisis().getTime() ) );
			if (dto.getEstado() != null) {
				stmt.setInt( index++, dto.getEstado().intValue() );
			} else {
				stmt.setNull(index++, java.sql.Types.INTEGER);
			}
		
			stmt.setString( index++, dto.getComentariosCol() );
			stmt.setString( index++, dto.getComentariosAna() );
			stmt.setString( index++, dto.getRecomendaciones() );
			if (dto.getDiagnosticoini() != null) {
				stmt.setInt( index++, dto.getDiagnosticoini().intValue() );
			} else {
				stmt.setNull(index++, java.sql.Types.INTEGER);
			}
		
			if (dto.getDiagnosticofin() != null) {
				stmt.setInt( index++, dto.getDiagnosticofin().intValue() );
			} else {
				stmt.setNull(index++, java.sql.Types.INTEGER);
			}
		
			stmt.setString( index++, dto.getReferidor() );
			stmt.setString( index++, dto.getColocacionEnf() );
			stmt.setString( index++, dto.getColocacionMed() );
			stmt.setString( index++, dto.getAnalisisMed() );
			stmt.setString( index++, dto.getRetiradaEnf() );
			stmt.setString( index++, dto.getRetiradaMed() );
			stmt.setString( index++, dto.getNproc() );
			stmt.setString( index++, dto.getDiaginiotro() );
			stmt.setString( index++, dto.getDiagfinotro() );
			//System.out.println( "Executing " + SQL_INSERT + " with DTO: " + dto );
			int rows = stmt.executeUpdate();
			long t2 = System.currentTimeMillis();
			//System.out.println( rows + " rows affected (" + (t2-t1) + " ms)" );
		
			// retrieve values from auto-increment columns
			rs = stmt.getGeneratedKeys();
			if (rs != null && rs.next()) {
				dto.setIdholter( new Integer( rs.getInt(1) ) );
			}
		
			reset(dto);
			auditoriaDto.setAccion(AuditoriaDto.insercion);
			auditoriaDto.setDescri(dto.toString());
			auditoriaDao.escribeAuditoria(auditoriaDto);
			return dto.createPk();
		}
		catch (Exception _e) {
			_e.printStackTrace();
			throw new HolterDaoException( "Exception: " + _e.getMessage(), _e );
		}
		finally {
			ResourceManager.close(stmt);
			if (!isConnSupplied) {
				ResourceManager.close(conn);
			}
		
		}
		
	}

	/** 
	 * Updates a single row in the holter table.
	 */
	public void update(HolterPk pk, Holter dto) throws HolterDaoException
	{
		long t1 = System.currentTimeMillis();
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		
		try {
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
		
			//System.out.println( "Executing " + SQL_UPDATE + " with DTO: " + dto );
			stmt = conn.prepareStatement( SQL_UPDATE );
			int index=1;
			if (dto.getIdholter() != null) {
				stmt.setInt( index++, dto.getIdholter().intValue() );
			} else {
				stmt.setNull(index++, java.sql.Types.INTEGER);
			}
		
			stmt.setDate(index++, dto.getFechacolocacion()==null ? null : new java.sql.Date( dto.getFechacolocacion().getTime() ) );
			stmt.setDate(index++, dto.getFechalectura()==null ? null : new java.sql.Date( dto.getFechalectura().getTime() ) );
			stmt.setDate(index++, dto.getFecharetirada()==null ? null : new java.sql.Date( dto.getFecharetirada().getTime() ) );
			stmt.setDate(index++, dto.getFechanalisis()==null ? null : new java.sql.Date( dto.getFechanalisis().getTime() ) );
			if (dto.getEstado() != null) {
				stmt.setInt( index++, dto.getEstado().intValue() );
			} else {
				stmt.setNull(index++, java.sql.Types.INTEGER);
			}
		
			stmt.setString( index++, dto.getComentariosCol() );
			stmt.setString( index++, dto.getComentariosAna() );
			stmt.setString( index++, dto.getRecomendaciones() );
			if (dto.getDiagnosticoini() != null) {
				stmt.setInt( index++, dto.getDiagnosticoini().intValue() );
			} else {
				stmt.setNull(index++, java.sql.Types.INTEGER);
			}
		
			if (dto.getDiagnosticofin() != null) {
				stmt.setInt( index++, dto.getDiagnosticofin().intValue() );
			} else {
				stmt.setNull(index++, java.sql.Types.INTEGER);
			}
		
			stmt.setString( index++, dto.getReferidor() );
			stmt.setString( index++, dto.getColocacionEnf() );
			stmt.setString( index++, dto.getColocacionMed() );
			stmt.setString( index++, dto.getAnalisisMed() );
			stmt.setString( index++, dto.getRetiradaEnf() );
			stmt.setString( index++, dto.getRetiradaMed() );
			stmt.setString( index++, dto.getNproc() );
			stmt.setString( index++, dto.getDiaginiotro() );
			stmt.setString( index++, dto.getDiagfinotro() );
			if (pk.getIdholter() != null) {
				stmt.setInt( 21, pk.getIdholter().intValue() );
			} else {
				stmt.setNull(21, java.sql.Types.INTEGER);
			}
		
			int rows = stmt.executeUpdate();
			reset(dto);
			long t2 = System.currentTimeMillis();
			auditoriaDto.setAccion(AuditoriaDto.modificacion);
			auditoriaDto.setDescri(dto.toString());
			auditoriaDao.escribeAuditoria(auditoriaDto);
			//System.out.println( rows + " rows affected (" + (t2-t1) + " ms)" );
		}
		catch (Exception _e) {
			_e.printStackTrace();
			throw new HolterDaoException( "Exception: " + _e.getMessage(), _e );
		}
		finally {
			ResourceManager.close(stmt);
			if (!isConnSupplied) {
				ResourceManager.close(conn);
			}
		
		}
		
	}

	/** 
	 * Deletes a single row in the holter table.
	 */
	public void delete(HolterPk pk) throws HolterDaoException
	{
		long t1 = System.currentTimeMillis();
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		
		try {
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
		
			//System.out.println( "Executing " + SQL_DELETE + " with PK: " + pk );
			stmt = conn.prepareStatement( SQL_DELETE );
			if (pk.getIdholter() != null) {
				stmt.setInt( 1, pk.getIdholter().intValue() );
			} else {
				stmt.setNull(1, java.sql.Types.INTEGER);
			}
		
			int rows = stmt.executeUpdate();
			long t2 = System.currentTimeMillis();
			//System.out.println( rows + " rows affected (" + (t2-t1) + " ms)" );
			auditoriaDto.setAccion(AuditoriaDto.borrado);
			auditoriaDto.setDescri(pk.toString());
			auditoriaDao.escribeAuditoria(auditoriaDto);
		}
		catch (Exception _e) {
			_e.printStackTrace();
			throw new HolterDaoException( "Exception: " + _e.getMessage(), _e );
		}
		finally {
			ResourceManager.close(stmt);
			if (!isConnSupplied) {
				ResourceManager.close(conn);
			}
		
		}
		
	}

	/** 
	 * Returns the rows from the holter table that matches the specified primary-key value.
	 */
	public Holter findByPrimaryKey(HolterPk pk) throws HolterDaoException
	{
		return findByPrimaryKey( pk.getIdholter() );
	}

	/** 
	 * Returns all rows from the holter table that match the criteria 'IDHOLTER = :idholter'.
	 */
	public Holter findByPrimaryKey(Integer idholter) throws HolterDaoException
	{
		Holter ret[] = findByDynamicSelect( SQL_SELECT + " WHERE IDHOLTER = ?", new Object[] { idholter } );
		return ret.length==0 ? null : ret[0];
	}

	/** 
	 * Returns all rows from the holter table that match the criteria ''.
	 */
	public Holter[] findAll() throws HolterDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " ORDER BY IDHOLTER", null );
	}

	/** 
	 * Returns all rows from the holter table that match the criteria 'IDHOLTER = :idholter'.
	 */
	public Holter[] findWhereIdholterEquals(int idholter) throws HolterDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE IDHOLTER = ? ORDER BY IDHOLTER", new Object[] {  new Integer(idholter) } );
	}

	/** 
	 * Returns all rows from the holter table that match the criteria 'FECHACOLOCACION = :fechacolocacion'.
	 */
	public Holter[] findWhereFechacolocacionEquals(Date fechacolocacion) throws HolterDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE FECHACOLOCACION = ? ORDER BY FECHACOLOCACION", new Object[] { fechacolocacion==null ? null : new java.sql.Date( fechacolocacion.getTime() ) } );
	}

	/** 
	 * Returns all rows from the holter table that match the criteria 'FECHALECTURA = :fechalectura'.
	 */
	public Holter[] findWhereFechalecturaEquals(Date fechalectura) throws HolterDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE FECHALECTURA = ? ORDER BY FECHALECTURA", new Object[] { fechalectura==null ? null : new java.sql.Date( fechalectura.getTime() ) } );
	}

	/** 
	 * Returns all rows from the holter table that match the criteria 'FECHARETIRADA = :fecharetirada'.
	 */
	public Holter[] findWhereFecharetiradaEquals(Date fecharetirada) throws HolterDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE FECHARETIRADA = ? ORDER BY FECHARETIRADA", new Object[] { fecharetirada==null ? null : new java.sql.Date( fecharetirada.getTime() ) } );
	}

	/** 
	 * Returns all rows from the holter table that match the criteria 'FECHANALISIS = :fechanalisis'.
	 */
	public Holter[] findWhereFechanalisisEquals(Date fechanalisis) throws HolterDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE FECHANALISIS = ? ORDER BY FECHANALISIS", new Object[] { fechanalisis==null ? null : new java.sql.Date( fechanalisis.getTime() ) } );
	}

	/** 
	 * Returns all rows from the holter table that match the criteria 'ESTADO = :estado'.
	 */
	public Holter[] findWhereEstadoEquals(int estado) throws HolterDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE ESTADO = ? ORDER BY ESTADO", new Object[] {  new Integer(estado) } );
	}

	/** 
	 * Returns all rows from the holter table that match the criteria 'COMENTARIOS_COL = :comentariosCol'.
	 */
	public Holter[] findWhereComentariosColEquals(String comentariosCol) throws HolterDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE COMENTARIOS_COL = ? ORDER BY COMENTARIOS_COL", new Object[] { comentariosCol } );
	}

	/** 
	 * Returns all rows from the holter table that match the criteria 'COMENTARIOS_ANA = :comentariosAna'.
	 */
	public Holter[] findWhereComentariosAnaEquals(String comentariosAna) throws HolterDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE COMENTARIOS_ANA = ? ORDER BY COMENTARIOS_ANA", new Object[] { comentariosAna } );
	}

	/** 
	 * Returns all rows from the holter table that match the criteria 'RECOMENDACIONES = :recomendaciones'.
	 */
	public Holter[] findWhereRecomendacionesEquals(String recomendaciones) throws HolterDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE RECOMENDACIONES = ? ORDER BY RECOMENDACIONES", new Object[] { recomendaciones } );
	}

	/** 
	 * Returns all rows from the holter table that match the criteria 'DIAGNOSTICOINI = :diagnosticoini'.
	 */
	public Holter[] findWhereDiagnosticoiniEquals(int diagnosticoini) throws HolterDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE DIAGNOSTICOINI = ? ORDER BY DIAGNOSTICOINI", new Object[] {  new Integer(diagnosticoini) } );
	}

	/** 
	 * Returns all rows from the holter table that match the criteria 'DIAGNOSTICOFIN = :diagnosticofin'.
	 */
	public Holter[] findWhereDiagnosticofinEquals(int diagnosticofin) throws HolterDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE DIAGNOSTICOFIN = ? ORDER BY DIAGNOSTICOFIN", new Object[] {  new Integer(diagnosticofin) } );
	}

	/** 
	 * Returns all rows from the holter table that match the criteria 'REFERIDOR = :referidor'.
	 */
	public Holter[] findWhereReferidorEquals(String referidor) throws HolterDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE REFERIDOR = ? ORDER BY REFERIDOR", new Object[] { referidor } );
	}

	/** 
	 * Returns all rows from the holter table that match the criteria 'COLOCACION_ENF = :colocacionEnf'.
	 */
	public Holter[] findWhereColocacionEnfEquals(String colocacionEnf) throws HolterDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE COLOCACION_ENF = ? ORDER BY COLOCACION_ENF", new Object[] { colocacionEnf } );
	}

	/** 
	 * Returns all rows from the holter table that match the criteria 'COLOCACION_MED = :colocacionMed'.
	 */
	public Holter[] findWhereColocacionMedEquals(String colocacionMed) throws HolterDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE COLOCACION_MED = ? ORDER BY COLOCACION_MED", new Object[] { colocacionMed } );
	}

	/** 
	 * Returns all rows from the holter table that match the criteria 'ANALISIS_MED = :analisisMed'.
	 */
	public Holter[] findWhereAnalisisMedEquals(String analisisMed) throws HolterDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE ANALISIS_MED = ? ORDER BY ANALISIS_MED", new Object[] { analisisMed } );
	}

	/** 
	 * Returns all rows from the holter table that match the criteria 'RETIRADA_ENF = :retiradaEnf'.
	 */
	public Holter[] findWhereRetiradaEnfEquals(String retiradaEnf) throws HolterDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE RETIRADA_ENF = ? ORDER BY RETIRADA_ENF", new Object[] { retiradaEnf } );
	}

	/** 
	 * Returns all rows from the holter table that match the criteria 'RETIRADA_MED = :retiradaMed'.
	 */
	public Holter[] findWhereRetiradaMedEquals(String retiradaMed) throws HolterDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE RETIRADA_MED = ? ORDER BY RETIRADA_MED", new Object[] { retiradaMed } );
	}

	/** 
	 * Returns all rows from the holter table that match the criteria 'NPROC = :nproc'.
	 */
	public Holter[] findWhereNprocEquals(String nproc) throws HolterDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE NPROC = ? ORDER BY NPROC", new Object[] { nproc } );
	}

	/** 
	 * Returns all rows from the holter table that match the criteria 'DIAGINIOTRO = :diaginiotro'.
	 */
	public Holter[] findWhereDiaginiotroEquals(String diaginiotro) throws HolterDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE DIAGINIOTRO = ? ORDER BY DIAGINIOTRO", new Object[] { diaginiotro } );
	}

	/** 
	 * Returns all rows from the holter table that match the criteria 'DIAGFINOTRO = :diagfinotro'.
	 */
	public Holter[] findWhereDiagfinotroEquals(String diagfinotro) throws HolterDaoException
	{
		return findByDynamicSelect( SQL_SELECT + " WHERE DIAGFINOTRO = ? ORDER BY DIAGFINOTRO", new Object[] { diagfinotro } );
	}

	/**
	 * Method 'HolterDaoImpl'
	 * 
	 */
	public HolterDaoImpl()
	{
	}

	public HolterDaoImpl(String usuario)
	{
		this.auditoriaDto = new AuditoriaDto(usuario, getTableName());
	}

	/**
	 * Method 'HolterDaoImpl'
	 * 
	 * @param userConn
	 */
	public HolterDaoImpl(final java.sql.Connection userConn)
	{
		this.userConn = userConn;
	}

	/** 
	 * Sets the value of maxRows
	 */
	public void setMaxRows(int maxRows)
	{
		this.maxRows = maxRows;
	}

	/** 
	 * Gets the value of maxRows
	 */
	public int getMaxRows()
	{
		return maxRows;
	}

	/**
	 * Method 'getTableName'
	 * 
	 * @return String
	 */
	public String getTableName()
	{
		//return "idea.holter";
		return "holter";
	}

	/** 
	 * Fetches a single row from the result set
	 */
	protected Holter fetchSingleResult(ResultSet rs) throws SQLException
	{
		if (rs.next()) {
			Holter dto = new Holter();
			populateDto( dto, rs);
			return dto;
		} else {
			return null;
		}
		
	}

	/** 
	 * Fetches multiple rows from the result set
	 */
	protected Holter[] fetchMultiResults(ResultSet rs) throws SQLException
	{
		Collection resultList = new ArrayList();
		while (rs.next()) {
			Holter dto = new Holter();
			populateDto( dto, rs);
			resultList.add( dto );
		}
		
		Holter ret[] = new Holter[ resultList.size() ];
		resultList.toArray( ret );
		return ret;
	}

	/** 
	 * Populates a DTO with data from a ResultSet
	 */
	protected void populateDto(Holter dto, ResultSet rs) throws SQLException
	{
		dto.setIdholter( new Integer( rs.getInt(COLUMN_IDHOLTER) ) );
		dto.setFechacolocacion( rs.getDate(COLUMN_FECHACOLOCACION ) );
		dto.setFechalectura( rs.getDate(COLUMN_FECHALECTURA ) );
		dto.setFecharetirada( rs.getDate(COLUMN_FECHARETIRADA ) );
		dto.setFechanalisis( rs.getDate(COLUMN_FECHANALISIS ) );
		dto.setEstado( new Integer( rs.getInt(COLUMN_ESTADO) ) );
		if (rs.wasNull()) {
			dto.setEstado( null );
		}
		
		dto.setComentariosCol( rs.getString( COLUMN_COMENTARIOS_COL ) );
		dto.setComentariosAna( rs.getString( COLUMN_COMENTARIOS_ANA ) );
		dto.setRecomendaciones( rs.getString( COLUMN_RECOMENDACIONES ) );
		dto.setDiagnosticoini( new Integer( rs.getInt(COLUMN_DIAGNOSTICOINI) ) );
		if (rs.wasNull()) {
			dto.setDiagnosticoini( null );
		}
		
		dto.setDiagnosticofin( new Integer( rs.getInt(COLUMN_DIAGNOSTICOFIN) ) );
		if (rs.wasNull()) {
			dto.setDiagnosticofin( null );
		}
		
		dto.setReferidor( rs.getString( COLUMN_REFERIDOR ) );
		dto.setColocacionEnf( rs.getString( COLUMN_COLOCACION_ENF ) );
		dto.setColocacionMed( rs.getString( COLUMN_COLOCACION_MED ) );
		dto.setAnalisisMed( rs.getString( COLUMN_ANALISIS_MED ) );
		dto.setRetiradaEnf( rs.getString( COLUMN_RETIRADA_ENF ) );
		dto.setRetiradaMed( rs.getString( COLUMN_RETIRADA_MED ) );
		dto.setNproc( rs.getString( COLUMN_NPROC ) );
		dto.setDiaginiotro( rs.getString( COLUMN_DIAGINIOTRO ) );
		dto.setDiagfinotro( rs.getString( COLUMN_DIAGFINOTRO ) );
	}

	/** 
	 * Resets the modified attributes in the DTO
	 */
	protected void reset(Holter dto)
	{
	}

	/** 
	 * Returns all rows from the holter table that match the specified arbitrary SQL statement
	 */
	public Holter[] findByDynamicSelect(String sql, Object[] sqlParams) throws HolterDaoException
	{
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		
		try {
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
		
			// construct the SQL statement
			final String SQL = sql;
		
		
			//System.out.println( "Executing " + SQL );
			// prepare statement
			stmt = conn.prepareStatement( SQL );
			stmt.setMaxRows( maxRows );
		
			// bind parameters
			for (int i=0; sqlParams!=null && i<sqlParams.length; i++ ) {
				stmt.setObject( i+1, sqlParams[i] );
			}
		
		
			rs = stmt.executeQuery();
		
			// fetch the results
			return fetchMultiResults(rs);
		}
		catch (Exception _e) {
			_e.printStackTrace();
			throw new HolterDaoException( "Exception: " + _e.getMessage(), _e );
		}
		finally {
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied) {
				ResourceManager.close(conn);
			}
		
		}
		
	}

	public ArrayList<ArrayList<Object>> findByDynamicSelect(String sql) throws HolterDaoException
	{
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		
		try {
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
		
			// construct the SQL statement
			final String SQL = sql;
		
		
			// prepare statement
			stmt = conn.prepareStatement( SQL );
			stmt.setMaxRows( maxRows );
		
			rs = stmt.executeQuery();
		
			// fetch the results
			return UtilCodifi.Results2Array(rs);
		}
		catch (Exception _e) {
			throw new HolterDaoException( "Exception: " + _e.getMessage(), _e );
		}
		finally {
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied) {
				ResourceManager.close(conn);
			}
		
		}
		
	}
	
	/** 
	 * Returns all rows from the holter table that match the specified arbitrary SQL statement
	 */
	public Holter[] findByDynamicWhere(String sql, Object[] sqlParams) throws HolterDaoException
	{
		// declare variables
		final boolean isConnSupplied = (userConn != null);
		Connection conn = null;
		PreparedStatement stmt = null;
		ResultSet rs = null;
		
		try {
			// get the user-specified connection or get a connection from the ResourceManager
			conn = isConnSupplied ? userConn : ResourceManager.getConnection();
		
			// construct the SQL statement
			final String SQL = SQL_SELECT + " WHERE " + sql;
		
		
			//System.out.println( "Executing " + SQL );
			// prepare statement
			stmt = conn.prepareStatement( SQL );
			stmt.setMaxRows( maxRows );
		
			// bind parameters
			for (int i=0; sqlParams!=null && i<sqlParams.length; i++ ) {
				stmt.setObject( i+1, sqlParams[i] );
			}
		
		
			rs = stmt.executeQuery();
		
			// fetch the results
			return fetchMultiResults(rs);
		}
		catch (Exception _e) {
			_e.printStackTrace();
			throw new HolterDaoException( "Exception: " + _e.getMessage(), _e );
		}
		finally {
			ResourceManager.close(rs);
			ResourceManager.close(stmt);
			if (!isConnSupplied) {
				ResourceManager.close(conn);
			}
		
		}
		
	}
	
	public ArrayList<ArrayList<Object>> getEstadisticasHolter(Date fechaini, Date fechafin) throws HolterDaoException{
		StringBuffer sql = new StringBuffer();
		sql.append("select hol.diagnosticofin DIAGNOSTICOFIN ");
		sql.append(" from procedimiento proc, ");
		sql.append(" holter hol ");
		sql.append(" WHERE proc.fecha between '"+UtilFechas.getFechaString(fechaini)+"' and '"+UtilFechas.getFechaString(fechafin)+"'");
		sql.append(" and proc.tipoprocedimiento = 1089 ");
		sql.append(" and proc.idprocedimiento = hol.idholter ");
		
		return findByDynamicSelect(sql.toString());
	}
	
	public ArrayList<ArrayList<Object>> getEstadisticas(Date fechaini, Date fechafin, int ind)throws HolterDaoException{
		StringBuffer sql = new StringBuffer();
		sql.append("select pac.nhc NHC,");
		sql.append("pac.nombre NOMBRE,");
		sql.append("pac.apellid1 APELLID1,");
		sql.append("pac.apellid2 APELLID2,");
		sql.append("pac.fechanaci FECHANACI,");
		sql.append("proc.fecha FECHA,");//5
		sql.append("hol.fechacolocacion FECHACOLOCACION, ");
		sql.append("hol.fechalectura FECHALECTURA,");
		sql.append("hol.fecharetirada FECHARETIRADA,");
		sql.append("hol.fechanalisis FECHANALISIS,");
		sql.append("hol.estado ESTADO,");//10
		sql.append("hol.comentarios_col COMENTARIOS_COLOCACION,");
		sql.append("hol.comentarios_ana COMENTARIOS_ANALISIS,");
		sql.append("hol.recomendaciones RECOMENDACIONES,");
		sql.append("hol.diagnosticoini DIAGNOSTICO_INICIAL,");
		sql.append("hol.diagnosticofin DIAGNOSTICO_FINAL,");//15
		sql.append("hol.referidor REFERIDOR,");
		sql.append("hol.colocacion_enf COLOCACION_OPENF,");
		sql.append("hol.colocacion_med COLOCACION_OPMED,");
		sql.append("hol.analisis_med ANALISIS_OPMED,");
		sql.append("hol.retirada_med RETIRADA_OPMED,");//20
		sql.append("hol.retirada_enf RETIRADA_OPENF,");
		sql.append("hol.nproc NUM_PROCEDIMIENTO,");
		sql.append("hol.diaginiotro DIAGOSTICO_INICIAL_OTRO,");
		sql.append("hol.diagfinotro DIAGOSTICO_FINAL_OTRO,");
		sql.append("pac.nuhsa NUHSA");//25
		sql.append(" from procedimiento proc, ");
		sql.append(" arr_pacientes pac, ");
		sql.append(" holter hol ");
		sql.append(" WHERE proc.fecha between '"+UtilFechas.getFechaString(fechaini)+"' and '"+UtilFechas.getFechaString(fechafin)+"'");
		sql.append(" and proc.tipoprocedimiento = 1089 ");
		sql.append(" and pac.codigo = proc.codigo ");
		sql.append(" and proc.idprocedimiento = hol.idholter ");
		if(ind!=0)
			sql.append(" and hol.diagnosticofin = "+ind);
		
		return findByDynamicSelect(sql.toString());
	}

}
